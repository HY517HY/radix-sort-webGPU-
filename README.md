# 基数排序并行--->以webGPU为例
基数排序被称为最稳定的排序方法，且由于基于每次的每次迭代所以元素都会被遍历，因此基数排序非常适合做并行。
# 基数排序GPU的两大核心要点：  
1.GPU实现前缀和；  
2.计算基组偏移量实现索引分配。
# webGPU计算的基础知识
1.工作组（工作组id：workgroup_id）：一个工作组由workgroup_size（可指定）个线程（工作项）进行的。同一工作组的所有工作项可以访问共享内存var<workgroup>定义的遍历，且并行运行，可以利用workgroupBarrier()同步工作组中的工作项操作。  
2.工作项：具体全局唯一ID：global_invocation_id和某个工作组中的局部ID：local_invocation_id。  
GPU的运行机制是根绝GPU的线程数和workgroup_size来评估需要多少个工作组，但线程不够分配时只能串行执行。
# GPU实现基数排序
由于GPU读取数据的本质是二进制数据，所有选择基数时只能选取2的幂次。（CPU串行时基数选择10），本文选择基数为4进行推导，基为：00、01、10、11。注意迭代轮次取决于数据的位数。  
主要核心思路分两步：  
1.偏移量确定索引index：  
设数据的大小为length，创建一个大小为length * 4的数组bool，bool可看成四段，每一段表示一个基的特性，bool数据[0,length-1]的元素分别对应元素是否属于00基，以及类推。接着分别对bool的四段分别求前缀和假设前缀和数组为sum，则对于元素i，如其属于基01，则其索引为：index[i] = sum[length-1] + sum[length + i]-1。  
2.kogge-stone求前缀和：  
详细介绍：https://zhuanlan.zhihu.com/p/105842302  
和kogge-stone相关的两个量：工作组和工作组数量。事实上，就是对每个工作组进行kogge扫面算出每个工作组的前的前缀和，再根据组间偏移量算出最后的前缀和。注意，这里的偏移量时工作组间而上一步的偏移量是基组间，二者的概念不能混淆。由于数组的长度不太可能完美匹配workgroup_size，索引最后一个工作组的数据小于workgroup_size，需要进行补0操作。
